参考文件：http://www.cnblogs.com/ityouknow/p/5603287.html?spm=a2c4e.11153940.blogcont91260.10.6b936035bl6xb7

一：类加载定义

类加载定义：
    类的加载指的是将类的.class文件中的二进制数据读入内存中，将其放在运行时数据区的方法区中
然后在堆中创建class对象，用来分装类在方法区中的数据结构

二：生命周期

类加载：加载、连接（验证、准备、解析）、初时化、使用、卸载

加载：查找并加载二进制数据

    加载是类加载的第一阶段，载加载阶段：
        1、通过类的全限定名来获取二进制字节流
        2、将二进制的内容转化为方法区运行时的数据结构
        3、在堆中生成class对像，作为访问方法区中数据的入口

验证：确保被加载的类的正确性

    验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，
    并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作：

    文件格式验证：验证字节流是否符合Class文件格式的规范；例如：是否以0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。

    元数据验证：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了java.lang.Object之外。

    字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。

    符号引用验证：确保解析动作能正确执行。

准备：为类的静态变量分配内存，并将其初始化为默认值

解析：把类中的符号引用转换为直接引用

初始化：为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式：

  ①声明类变量是指定初始值

  ②使用静态代码块为类变量指定初始值

JVM初始化步骤

 1、假如这个类还没有被加载和连接，则程序先加载并连接该类

 2、假如该类的直接父类还没有被初始化，则先初始化其直接父类

 3、假如类中有初始化语句，则系统依次执行这些初始化语句

类初始化时机：只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种：

– 创建类的实例，也就是new的方式

– 访问某个类或接口的静态变量，或者对该静态变量赋值

– 调用类的静态方法

– 反射（如Class.forName(“com.shengsiyuan.Test”)）

– 初始化某个类的子类，则其父类也会被初始化

– Java虚拟机启动时被标明为启动类的类（Java Test），直接使用java.exe命令来运行某个主类


结束生命周期

•在如下几种情况下，Java虚拟机将结束生命周期

– 执行了System.exit()方法

– 程序正常执行结束

– 程序在执行过程中遇到了异常或错误而异常终止

– 由于操作系统出现错误而导致Java虚拟机进程终止



三：类加载器
站在jvm角度分类：
启动类加载器（Bootstrap ClassLoader） 由C++实现的，是虚拟机的一部分；
其他类加载器：由java实现 全部继承java.lang.ClassLoader(由启动类加载器加载到内存后才能使用)

站在开发角度：
启动类加载器：Bootstrap ClassLoader，负责加载存放在JDK\jre\lib(JDK代表JDK的安装目录，下同)下，
    或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，
    所有的java.*开头的类均被Bootstrap ClassLoader加载）。启动类加载器是无法被Java程序直接引用的。

扩展类加载器：Extension ClassLoader，该加载器由sun.misc.Launcher$ExtClassLoader实现，
    它负责加载DK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.*开头的类），
    开发者可以直接使用扩展类加载器。

应用程序类加载器：Application ClassLoader，该类加载器由sun.misc.Launcher$AppClassLoader来实现，
    它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，
    一般情况下这个就是程序中默认的类加载器。
四：自定义类加载器：

应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。
因为JVM自带的ClassLoader只是懂得从本地文件系统加载标准的java class文件，
因此如果编写了自己的ClassLoader，便可以做到如下几点：

1）在执行非置信代码之前，自动验证数字签名。

2）动态地创建符合用户特定需要的定制化构建类。

3）从特定的场所取得java class，例如数据库中和网络中。

五：类加载机制

•全盘负责，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，
除非显示使用另外一个类加载器来载入

•父类委托，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类

•缓存机制，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，
只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，
程序的修改才会生效


类加载有三种方式：

1、命令行启动应用时候由JVM初始化加载

2、通过Class.forName()方法动态加载

3、通过ClassLoader.loadClass()方法动态加载

Class.forName()和ClassLoader.loadClass()区别：

Class.forName()：将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块；

ClassLoader.loadClass()：只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,
只有在newInstance才会去执行static块。

六：双亲委派模型
双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，
而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，
只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。



