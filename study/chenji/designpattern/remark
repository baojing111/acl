plantUNL安装：
https://www.jianshu.com/p/a6bd7e3048ef
https://blog.csdn.net/qq_36847641/article/details/78224910

plantUml 类图语法 ：https://blog.csdn.net/changsimeng/article/details/54410986


设计模式学习：http://www.runoob.com/design-pattern/builder-pattern.html

设计模式：

 创建型：
        单例模式：保证一个类仅由一个实例，并提供一个访问它的全局访问点
        简单工厂模式（0_simple_factory_pattern）：由一个工厂对象决定创建出哪一种产品类的实例
        工厂方法模式（1_factory_method_pattern）：定义一个用于创建对象的接口，让子类决定实例化哪一个类，
                                              工厂方法使一个类的实例化延迟到其子类。
        抽象工厂模式（2_abstract_factory_pattern）：提供一个创建一系列相关或者相互依赖对象的接口，而无
                                                需指定他们的具体的类。
        建造者模式（3_builder_pattern）：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。
        原型模式：用原型实例指定创建对象的种类，并通过拷贝这些原型创建新对象。


 结构型：
        适配器模式：将一个接口转换成客户客户希望的接口，使得原本不能一起工作的类可以一起工作
        桥接模式(5_bridge_pattern):将抽象部分与它的实现部分分离使它们都可以独立的变化（由于实现的方式有多种，桥接模式的意图是把这些现实独立出来，让它们独自变化）
        组合模式(7_composite_entity_pattern)：将对像组合成树形结构，表示部分-整体的层次结构，组合模式使得用户对单个对象的和组合对象的使用具有一致性
        享元模式（8_flyweight_pattern）：运用共享技术有效地支持大量细粒度的对象。
        装饰模式(6_decorator_pattern)：动态地给一个对象添加额外的职能，就增加功能来说，比生成子类更为灵活
        代理模式：为其他对象提供一种代理以控制这个对象的访问
        外观模式(4_facade_pattern)：为子系统中的一组接口提供一个高层的接口，使得子系统更加容易使用

 行为型：
        策略模式(9_strategy_pattern)：定义类算法家族，分别分装起来，让它们之间可以相互替换，使得算法的变化，不影响到使用算法的客户
        命令模式（10_command_pattern）：将请求分装成对象，从而使你可用不同的请求对客户端参数化
        状态模式（11_state_pattern）：允许对象内部发生变化时改变其行为
        模版模式(12_template_pattern)：定义一个算法的骨架，将一些步骤的实现延迟到子类中，使得子类可以不改变算法的骨架下，定义部分算法的实现
        责任链模式(13_chain_of_responsibility_pattern)：使得多个对象都可以处理请求，避免请求者和接收者耦合在一起，将对象连接成一条链，并且沿着这条链传递请求，直到有对像处理请求。
        观察者模式：定义了一种一对多的的依赖关系，让多个观察者对像同时观察一个主题对象，这个主题对象状态发生变化时，会通知个个观察者，使他们能够自动更新自己。